<!doctype html><html lang=en><head><title>Christmas Lights Version 2 · Noah Virjee
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Noah Virjee"><meta name=description content="This project is a continuation of my Christmas Lights project.
Overview Link to heading My Christmas tree lights project involved playing video on a set of addressable Christmas tree lights.
The program first determines the relative positions of the lights by turning on each light in sequence and using a camera to see where they are. This generates a list of coordinates which are stored on disk. Then for each frame of a video, the program resizes the frame to fit the light positions, then assigns each light the corresponding color at that point on the frame."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Christmas Lights Version 2"><meta name=twitter:description content="This project is a continuation of my Christmas Lights project.
Overview Link to heading My Christmas tree lights project involved playing video on a set of addressable Christmas tree lights.
The program first determines the relative positions of the lights by turning on each light in sequence and using a camera to see where they are. This generates a list of coordinates which are stored on disk. Then for each frame of a video, the program resizes the frame to fit the light positions, then assigns each light the corresponding color at that point on the frame."><meta property="og:title" content="Christmas Lights Version 2"><meta property="og:description" content="This project is a continuation of my Christmas Lights project.
Overview Link to heading My Christmas tree lights project involved playing video on a set of addressable Christmas tree lights.
The program first determines the relative positions of the lights by turning on each light in sequence and using a camera to see where they are. This generates a list of coordinates which are stored on disk. Then for each frame of a video, the program resizes the frame to fit the light positions, then assigns each light the corresponding color at that point on the frame."><meta property="og:type" content="article"><meta property="og:url" content="https://blucardin.github.io/projects/christmas-lights-v2/"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-01-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-04T00:00:00+00:00"><link rel=canonical href=https://blucardin.github.io/projects/christmas-lights-v2/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.5adbe72fc41dcfb852215b84695288939b6b606db73238bd3ee936469572fc9c.css integrity="sha256-WtvnL8Qdz7hSIVuEaVKIk5trYG23Mji9Puk2RpVy/Jw=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Noah Virjee
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/contact/>Contact me</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://blucardin.github.io/projects/christmas-lights-v2/>Christmas Lights Version 2</a></h1></header><iframe width=100% height=475 src="https://www.youtube.com/embed/qRL0N3ooU7c?si=6yHi9NtoIwvrpivd" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>This project is a continuation of my <a href=/projects/chrsistmas-lights>Christmas Lights</a> project.</p><h2 id=overview>Overview
<a class=heading-link href=#overview><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>My Christmas tree lights project involved playing video on a set of addressable Christmas tree lights.</p><p>The program first determines the relative positions of the lights by turning on each light in sequence and using a camera to see where they are. This generates a list of coordinates which are stored on disk. Then for each frame of a video, the program resizes the frame to fit the light positions, then assigns each light the corresponding color at that point on the frame. Finally, it displays each frame on the light in sequence.</p><p>The lights were driven by a raspberry pi with low compute capacity. To increase speed, operations were split into different parts and run between my laptop and the pi. The pi would calculate the positions. Using the positions my laptop would calculate the colors for each frame. Using the colors for each frame, the pi would display the images. The laptop was connected to the pi via SSH over my home network allowing me to play video from anywhere in my home.</p><h2 id=origins>Origins
<a class=heading-link href=#origins><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>My father wanted to buy a new set of Christmas lights. After looking for some online, I found a set that was addressable, and my mind immediately imagined a Christmas tree that also functioned as a video display. For Christmas that year I got 500 LED lights to play with.</p><h2 id=challenges>Challenges
<a class=heading-link href=#challenges><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>At first, I just tried to get the lights up and running. However, they were not addressing properly. I would write code for one LED to turn on and four would light up. After doing some research I found out that, the raspberry pi outputs data signals at 3.3V, while the lights could only properly recognize a data signal at 5V. I used a level shifter to transform the 3.3V signal into 5V.</p><p>Now that the lights were working. I started to think about how I would play video. Unlike a regular computer screen, if the lights were on a Christmas tree they would be scattered randomly. I found that the best plan was to remove the randomness by determining the positions, then overlaying the image, and finally displaying the lights with the corresponding colors.</p><p>After I was done coding, I tested the system with the lights on a table. I found that the camera was not able to determine the positions of the lights. It would take a photo of one bright LED and determine the brightest spot of the image to be in a completely different place. I realized that this behavior could be resolved by applying a gaussian blur to the image before I found the brightest pixel. Bright noise pixels are usually surrounded by dim pixels, so they would become a lower brightness. On the other hand, bright pixels showing LEDs were usually surrounded by other bright pixels, so they would stay at a similar intensity. This allowed me to find accurate positions of the lights. I even did some trials to statistically determine the best gaussian blur radius for the lights.</p><p>Finally, after all the kinks were worked out, I put the lights on the tree and observed my amazing creation. I found that the best use of the lights was to put on cool designs in the background as mood lighting because you can repeat the video indefinitely.</p><h2 id=code>Code
<a class=heading-link href=#code><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>All my code can be found here: <a href=https://github.com/blucardin/ChirstmasLights3 class=external-link target=_blank rel=noopener>https://github.com/blucardin/ChirstmasLights3</a></p><p>My favourite code snippet is <a href=https://github.com/blucardin/ChirstmasLights3/blob/fbe1477272c4b232e4957e58bc052220cb1e5f1e/detectingPositions/detect_lightAllnewHighRes.py#L47C1-L54C48 class=external-link target=_blank rel=noopener>“detectingPositions/detect_lightAllnewHighRes.py” lines 46-55</a></p><script src=https://gist.github.com/blucardin/a676879e1eebba0680679f1959888b77.js></script><p>This code reads a frame from the camera, converts it to grayscale, applies a gaussian blur of radius GaussianRadius, and finally finds the location of the pixel with the greatest intensity (maxLoc).</p><p>I wanted to show this section of the code off because of its simplicity, utility, and ingenuity. This routine to determine the positions of the lights is the core of the project. These five lines took me a lot of head-scratching to come up with and solved a lot of my problems by using a gaussian blur to greatly increase the accuracy of the generated positions.</p><p>I can manually determine the position of a light by displaying the camera image to the screen and clicking it.</p><p>We can compare a manually generated position with an autogenerated position by calculating the Euclidian distance between the two points using the Pythagorean theorem.</p><p>After running this snippet of code with several gaussian radius sizes and comparing them with 50 manually generated positions on the same set of lights, we get the graph below.</p><img width=70% alt=image src=https://github.com/blucardin/blucardin.github.io/assets/55935207/6b2a0ff9-fbdd-46d1-8033-1740dac937ed><p>This shows that, under testing conditions, implementing a gaussian blur of radius 15 would result in points almost the same as if a human had picked them out and with relatively low variability.</p><h2 id=faults>Faults
<a class=heading-link href=#faults><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The system worked amazing for high contrast or high saturation images with low minimum resolution. However, when the image was low contrast, low saturation, or needed lots of detail to understand, the lights did not display them nicely. I think this comes from the lights themselves not having completely accurate color mixing as they were made for high saturation colors. The LEDs also blur into each other dulling contrast. And of course, with only 500 pixels in a random distribution on a tree, detail is limited.</p><p>Determining the positions of the lights also needed relatively low light to be accurate. If there were any sources of light in the image other than the lights themselves, the positioning system would break down. If I would do the project again, I would experiment with different means of determining the positions. Maybe creating some machine learning algorithm to detect the LED instead of relying on brightness values.</p><h2 id=applications>Applications
<a class=heading-link href=#applications><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Other than looking cool and being an interesting conversation piece on your tree, this project has some useful applications.</p><p>First, as a teaching tool. These lights combine electronics, software, image analysis, and computer networking in an easy to understand and interesting looking package. I have used this project to show beginner programmers what you can do with code. Plus, the lights interface is so easy to use, even a python beginner can make cool designs with it.</p><p>Second, in concert wristbands. At concerts, concertgoers are given wristbands that light up with different colors to create displays on the crowd. Current methods of lighting up with wristbands are very imprecise, lighting up large sections of lights with the same color. Imagine if each wristband was equipped with an infrared LED that could be located by a camera before the show. A command center could then calculate the color of each wristband and update them over radio signals to show an image. Using a similar method to my Christmas tree, artists can use their crowd as a display.</p><p><img src=https://github.com/blucardin/blucardin.github.io/assets/55935207/9b231254-0045-4e49-959f-244ad3f50271 alt=image></p><h2 id=sources>Sources
<a class=heading-link href=#sources><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To learn how to operate the lights and connect them to my raspberry pi, I used Abigail Torre’s article titled, “NeoPixels on Raspberry Pi” <a href=https://learn.adafruit.com/neopixels-on-raspberry-pi/python-usage class=external-link target=_blank rel=noopener>https://learn.adafruit.com/neopixels-on-raspberry-pi/python-usage</a>. This information in this article was only used for connecting to the lights and usage of the CircuitPython NeoPixel library. I wrote all the code for the project myself.</p><p>I used the Open Source Computer Vision (OpenCV) library for working with images (taking a photo, blurring it, determining the greatest pixel etc.). I had prior knowledge of the library and used their documentation here: <a href=https://docs.opencv.org/4.x/index.html class=external-link target=_blank rel=noopener>https://docs.opencv.org/4.x/index.html</a></p><p>Information and images of concert lights came from this Wall Street Journal article entitled, “The Tech Behind How Concert LED Light Wristbands Work” <a href=https://www.wsj.com/video/series/tech-behind/the-tech-behind-how-concert-led-light-wristbands-work/EAA54145-D07A-4100-8153-2EAF8D671921 class=external-link target=_blank rel=noopener>https://www.wsj.com/video/series/tech-behind/the-tech-behind-how-concert-led-light-wristbands-work/EAA54145-D07A-4100-8153-2EAF8D671921</a></p></article></section></div><footer class=footer><section class=container>©
2022 -
2024
Noah Virjee
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZQXMHVPTE6"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZQXMHVPTE6")</script></body></html>